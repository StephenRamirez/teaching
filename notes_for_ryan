this is our place where i will teach ryan how to make iphone apps

@interface <--- this alllows you to declare a class 

ex:  @interface Test : NSObject 

if you noticed the NSObject this is the super class 
this means the Test class inherits the methods and instance variables from the NSObject class and can use them

next chapter

you are able to store variables in an object and heres how you do it

ex: @interface Test : NSObject {

int x;
int y;

}

this means that a number variable x and y are stored within the Test class

now lets say you want to preform a function from the Test class 
well you would need to define it first so lets make one!

ex: @interface Test : NSObject {

int x;
int y;

}

-(void)print;

in the header file where this interface function is placed you to not say what the funciton does but simply initiliaze that it is there and that the 
class can see it and containes it
//(I'm gonna do comments c++ style, since that's what I'm used to)
//okay, so you initialize the function, but don't tell it what to do? How then does the compiler know what to make the function do? Is it
//within the NSObject class?

Great Question! next chapter!

now we will go over how to tell the program what the initialized function is going to preform 
to do this you need to implement the code for the funtion in the main file instead of the header file where the @interface function is located

@implementation <--- this allows you to implement what the funciton are supposed to do

once again this is located in the main file not the header like the previous phrase

ex: @implementation Test

-(void)print {

NSLog("Hello World!");

}

This snippet of code says you are implementing code into functions of the Test class and then you difine them as so
by re typing the name of the function and then what it does


//Okay, so it looks like we've got a class now with two variables in it, x and y, and a function to print "Hello World!" onto the screen. Great.
//Now how do you put it together? As in, how do you write the code to actually make it compile and print "Hello World!" onto the screen?

another great question! which seems to also go into the next chapter! next chapter!

there are two ways to do this! i will teach both

one is used in the main function

and the other runs using the word self to access the methods without having to create a seperate object
====================================================================================================================

in the main function you need to create an object to use the preset methods applied to your class.

ex: int main() {

Test *myTest = [[Test alloc] init];

[myTest print];

[myTest release];

}

this allocates the methods and variables and initilizes them so they exsist and are usable
REMEBER TO RELEASE THE MEMORY OF THE OBJECT YOU CREATED SO THAT THE IPHONE DOESNT EXPLODE 
although! the new xcode now allows you to not need to release the object for now it does it for you
=======================================================================================================

now lets go over something you will be seeing alot more often in the xcode development tool 

instead of creating an object to use these variables you can use the word self to refer to the last object that recieved a message in this case thats the object you have been adding to
you code would not be in the main fuction but in other functions located in the main file for the view controller(the screen at the current point in code for the iphone)

ex: 

-(void)ViewDidLoad {

[self print];

}

so basically in xcode there are a bunch of functions placed in the code already that are meant to do certain things
the one that i put on the screen is performed once the screen loads 
thus once the screen loads the object that was last refered to which was the one we made is accessed and the method print from that object is performed
==============================================================================================================================================================

//okay, relatively simple...
//do you happen to have like, a picture of what the IDE looks like for programming iPhone apps? I think that might help a little...
//other than that though, no questions that I can think of, so...next chapter!

I have pictures of it ill send them to you on your phone shortly

Next Chapter - More on the Self Keyword

Now you might ask why put the self keyword before the function and not just only put the name of the function 

Well here is why!

lets say we have the class person!

@interface Person : NSObject {

int height;
int speed;

}

-(void)setHeight:(int) x;
-(void)setSpeed:(int) x;

@end

Here is our class!
Simply put this class has two variables and two setter methods that set those variables
now lets implement them

@implementation Person;

-(void)setHeight:(int) x {

height = x;

}

-(void)setSpeed:(int) x {

speed = x;

}

@end

Now lets think 
Pretend we have made two objects according to this class we have just made
and think of this line of code below

-(void)ViewDidLoad {

[self setHeight:6];

[self setSpeed:40];

}

if you had not put the self keyword there which object would that method be responding to?
Exactly this means you can have methods within a methods of an object and use the self word to refer to the object that called that method to call more methods
the self word adapts to the object that uses it so this function would set the height and speed of any object you make and use this method to do so

The self word is very use full that is why i needed to put an extra chapter for it
===============================================================================================================================================================================
//Ohhh, I just got it. Makes sense now. What's next?

//Sorry I was gone for so long. Just got super busy is all. I'm back now and ready to learn
//Okay, so, I get what the program here does. It's relatively simple, I can follow it along. There's only one thing I don't quite understand
//what's the print function display on the screen? like, I get what NSLog does, but I have no idea how to use it. What's up with the
//@"%i %i" in the function call (the function call for NSLog within the definition of print)?
===============================================================================================================================================================================

NEXT CHAPTER - UI objects!

these objects are the objects that are visible on the screen to drag and drop

you can simply drag a label to the screen but to make the code edit this label is another story

The Keyword IBOutlet <--- this word links your code to this object!

EX:

@interface Test : NSObject {

IBOutlet UILabel *mylabel;

}

-(void)setLabel;

@end

===============================================================================================================================================================================

now if you go back to the drag and drop sceen in this box on the side you can now link mylabel to the actual label 
on the screen!

now to edit it!

there are many ways this one is the easiest!

EX:

@implementation Test;

-(void)setLabel {

mylabel.text = @"this is a test";

}

-(void)ViewOnLoad {

[self setLabel];

}

@end

=================================================================================================================================================================================

this will imediatly on load set the label to "this is a test" 

//simple enough. now what?
//Oh, and one more thing...forgot to mention this in the last update...
//Sometime before the test for this, could you actually show me on your actual computer how to write these things? That way the test isn't
//the first app I've ever made...plus I think it would help a lot to actually be able to write and run them in an xcode compiler. So...
//ya, that'd be nice, if possible.